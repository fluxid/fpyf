Another lib allowing to create small web apps quickly, usable with flup and uwsgi.

Work is in progress, many work is still needed.
File uploads and big file downloads are not yet supported.
Sessions, database connections, templates etc: DIY
Getting data from GET and POST isn't elegant like in Django, but
it will be soon.

Comments and help welcome.

Example usage (not actually tested, but it should give the idea):

from pyff import Routing, Application, Controller

# First make something which will render templates and cleanup database
# after request, and also handle errors
# It's required to make things even nicer if we are using db connections
# and templates, like sqlalchemy+mako or something like that

def expose(template=None, content_type=None, encoding=None):
    def decorator(f):
        def wrapper(request, proto, *args, **kwargs):
            try:
                result = f(request, proto, *args, **kwargs)
                result = render(result, template)

                db.commit()
            except:
                result = traceback.format_exc()
                # with proto object, we can set output type and cookies
                # so we don't need to create response object
                proto.status = 500
                proto.content_type = 'text/plain'

                db.rollback()

            return result
        # Controller is only wrapper which makes use of proto object,
        # it's not actually needed to work. But without it we would
        # need to create Response objectts to redirect or set cookies, 
        # which is less elegant
        return update_wrapper(Controller(wrapper, content_type, encoding), f)
    return decorator

# Next, make controllers. Function must take at least three arguments
# request, proto and **kwargs.

@expose('template1.html')
def example1(request, proto, **kwargs):
    return dict(
        content='This dict will be rendered by template. Nothing much to do here',
    )

@expose('template2.html')
def example2(request, proto, **kwargs):
    # We'll get some data from GET
    # As I said, it's not elegant, yet
    return dict(
        a=request.GET.get('a', ['failsafe'])[0],
    )

@expose()
def example3(request, proto, **kwargs):
    # Set cookie and redirect
    proto.set_cookie('last_visit', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
    # This will work without return too, but afther calling this we can't set
    # any more cookies.
    return proto.redirect('/')

@expose('template3.html')
def example4(request, proto, param=None, **kwargs):
    # Let's get some info from pretty link, and return Not Found!
    proto.status = 404
    return dict(
        lol=param or 'Nothing!',
    )

# ~~ some less interesting controllers declared here ~~

ajax = (
    (r'/ex1/?', ajax1),
    (r'/ex2/?', ajax2),
)

route = (
    (r'/?$', example1),
    (r'/query_me/?$', example2),
    # We can include one route into another
    (r'/ajax', ajax),
    (r'/mark_as_read/?$', example3),
    (r'/yay(?:/(?P<param>.*?))?/?$', example4),
)

# if using uwsgi....
application = Application(Routing(route))

# or just make it working with flup
def run_fcgi():
    from flup.server.fcgi_fork import WSGIServer
    WSGIServer(application, bindAddress = ('127.0.0.1', 9001)).run()

if __name__ == '__main__':
    run_fcgi()
